- Фундаментальная идея в основе реактивного программирования: события - это данные, данные - это события.

- onNext() - передаёт каждый элемент вниз до Observer.
- onComplete() - свидетельствует о том, что нет больше никаких onNext().
- onError() - отправляет ошибку вниз по цепочке вплоть до самого Observer, где как правило определена обработка ошибок. Если не использован оператор retry(), то больше никаких айтемов не заэмитится.
 
- Observable.create()
    Фабрика, позволяющая создать Observable и обозначить эмиттер.
    Нужна для хуков вокруг нереактивных источников данных/событий.
    В первой rxJava это был Observable.fromEmitter().
	Стоит обратить внимание, что Observable может эмитить один элемент за период 
	времени.
    - map() и filter() возвращают новый Observable.

- Во второй rxJav'e нельзя эмиттить Null.

- Интерфейс Observer.
    Методы onNext(), onComplete(), onError() вообще-то определяют тип 
    обзёрвера.
    В первой эриксджаве это был Subscriber. Во второй Subscriber появляется
    только когда речь идёт о Flowables.
    Если при выпуске элементов в Observable произойдёт ошибка, то она
    упадёт в Observer.onError()  

- Функции в rxJava (аналогично Java8):

Имя					|	SAM			|	Описание
-------------------------------------------------------------
Action				|	run()		|	Запускает операцию, похоже на Runnable
Callable<T>			|	get()		|	Возвращает элемент типа T
Consumer<T>			|	accept()	|	Что-то делает над T, ничего не возвращает
Function<T,R>		|	apply()		|	Принимает T, возвращает R
Predicate<T>		|	test()		|	Принимает Т, возвращает boolean
BiConsumer<T1,T2>	|	accept		|	см.Consumer<T>
BiFunction<T1,T2,R>	|	apply()		|	Принимает T1,T2,возвращает R
BiPredicate<T1,T2>	|	test()		|	см.Predicate<T>
Function3<T1,T2,T3,R>|	apply()		|	Принимает три аргумента, возвращает R
BooleanSupplier		| getAsBoolean()|	Возвращает булю
LongConsumer		|	accept()	|	Что-то делает с входным лонгом и всё
IntFunction			|	apply()		| 	Принимает int и возвращает T	
			
- Cold vs Hot.
	Обсерваблы, которые эмитят конечные данные чаще всего cold (отрабатывают тогда,
	когда на них подписались). Горячие похожи на broadcast, вещают всем 
	подписчикам.
	Работает, как радио. Если пропустил трэк, его уже не услышишь. Горячие
	чаще всего отображают события, нежели какие-то данные.
	- ConnectableObservable - полезная форма горячего обзёрвабла. Он берёт любой
	Observable и делает из него hot, чтобы он эмитил всем подписчикам одновременно.
	Просто вызови publish() у любого обзёрвабла и он вернёт ConnectableObservable.
	Но subscribe на такой обзёрвабл не вызовет эмиты. У него надо вызвать
	connect(), чтобы тот начал пулять. То есть можно подписать несколько
	подписчиков на ConnectableObservable, потом ткнуть source.connect() 
	и только тогда все подписчики получат свои данные. Такая фиговина более
	известна, как Multicasting.

- Другие фабрики для создания Observable
	- Observable.range() - для создания последовательности интов. Создаётся до тех
	пор, пока не будет достигнут конечный инт. Все инты передаются через onNexT(),
	что неудивительно.
	- Observable.interval() - time-based обзёрвабл, который эмитит с заданным
	интервалом. Бесконечный. Cold.
	- Observable.future() - хер его знает, не особо-то описано. Обёртка над Future
	- Observable.empty() - ничего не эмитит и вызвает onComplete(). Вместо null'ов.
	- Observable.never() - похож на empty(), только никогда не вызывает
	  onComplete().
	- Observable.error() - вызывает onError().
	- Observable.defer() - какая-то мощная фиговина, так как может создавать 
	`separate state` для каждого Observable. Ну например нам нужно подтягивать
	изменившееся состояние в обзёрвабл.
	- Observable.fromCallable() - если нам надо произвести какое-то вычисление
	или операцию, а затем заэмитить его/её, можно просто вызвать Observable.just().
	Но иногда надо это проделать лениво. Также, если эта операция вызывает ошибку,
	лучше бы она её выкидывала только на момент её выполнения.
	Более того, если в Observable.just() ёбнет ошибка, то она не будет передана
	в Observer. Короче говоря, если то, что вы оборачиваете в Observable может
	вызывать ошибку, то оборачивать надо в Observable.fromCallable().

- Single, Completable, Maybe
	Есть три разных типа обзёрваблов, которые эмитят ноль или один элемент.
	- Single - эмитит, вот это поворот, один элемент.
	onSuccess() включает в себя onNext() и onComplete()
	В лямбде, соответственно, ловится onSuccess() и onError().
	- Maybe - если от количество элементов от 0 до 1.
	- Completable - придуман для того, чтобы выполнять какое-то действие. Ничего
	не получает. Есть onError() и onComplete().

- Disposing.
	Когда мы вызываем subscribe(), создаётся поток и обрабатывает emissions в
	цепочке. Для этого выделяются какие-то ресурсы. Слава Богу, Observable диспозит
	эти ресурсы как только отрабатывает onComplete(). Но в случае, если у нас 
	бесконечный или турбо долгий поток, нам может понадобится конкретный dispose.
	Короче нельзя доверять GC чистку толстых потоков и диспозить самому, чтобы 
	избежать мемори ликов.
	Disposable - это связующее звено между Observable и активным Observer. Можно 
	вызывать его dispose() для того, чтобы прекратить эмитить элементы и
	высвободить	все ресурсы, затраченные на их выпуск.
	- Disposable в обзёрвере. В onSubscribe(Disposable d) у обзёрвера передан
	disposable. Это нужно для того, чтобы обзёрвер мог контролировать подписку и
	мог отписаться в любой момент. Disposable передаётся по всей цепочке
	обзёрваблов. Вообще передача Observer'a в subscribe() не вернёт Disposable
	(rxJava сама захэндлит это вот всё), но если очень надо, то можно 
	юзануть subscribeWith(Disposable), тем самым получив дефолтный Disposable.
	- Использование CompositeDisposable. НужнО в случае, если у нас несколько
	подписок, а мы хотим манагить их (отписаться от всех разом, к примеру).

- Operators.
	Тут важно вкурить, что операторы сами являются Observer'ом для своего
	Observable выше по цепочке.
	- Suppressing operators.
	Эти операторы просто тупо не вызывают onNext(), если не проходит какое-то
	условие. Соответственно, элемент не проходит вниз по цепочке.
		- filter() - принимает Predicate<T> для обзёрвабла T. Каждый эмишн
		мапится в булю, которая говорит - подходит данный эмишн к условию или
		нет. Эмишены False дальше не проходят. Если вообще нет подходящих вариан-
		тов, то вернётся пустой Observable, ферштейн?
		- take() - у него несколько реализаций, тривиально.
		- skip() - противоположно take().
		- takeWhile(), skipWhile() - принимает/пропускает, пока соответствует
		условию.
		- takeUntil(), skipUntil() - принимают другой Observable в качестве пара-
		метра. Принимают/пропускают, пока другой обзёрвабл продолжае эмитить.
		- distinct() - будет эмитить каждый уникальный элемент, но подавлять пов-
		торяющиеся. Сравнение работает на hashcode()/equals() выпускаемых 
		объектов. Надо иметь в виду, что если если у нас дохрена уникальных
		элементов, то этот оператор будет есть память. Типа как если бы каждая
		подписка создавала HashSet, отслеживающий предыдущие выпущенные элементы.
		Можно также кинуть в distinct лямбду, по которой будет отобран
		уникальный ключ.
		- distinctUntilChanged() - полезная штуковина. Эмитит элементы, если
		входящие значения изменились. То есть она игнорит последовательно
		повторяющиеся элементы. 2,2,3,3,3,1,1 -> 2,3,1. Также принимает лямбду на
		вход, по которой собственно сравнивает элементы.
		[i] - в Tanderstore можно применять "новые" полученные политики только
		если они изменились - круто же.
		- elementAt() - можно получить специфичный эмишн по его id'шнику (long
		от 0 до Long.MAX_VALUE). Возвращает Maybe<T>. Разные у него реализации:
		elementAtOrError(): вернёт Single или Error (в случае, если по данному
		индексу нифига нет); singleElement(): вернёт Observable, обёрнутый в 
		Maybe; firstElement() и lastElement().
	- Transforming operators.
		- map() - для заданного Observable<T> меняет T на R, используя функцию
		Function<T,R>. Конвертирует один-к-одному каждый эмишн. Если нужно
		конвертить одно-в-несколько эмишнов, то надо использовать flatMap() или
		concatMap().
		- cast() - map-like оператор, который кастует каждый эмишн к заданному 
		типу. Некий такой брут-форс для приведения типов. Лучше правильно юзать
		дженерики, разумеется.
		- startWith() - позволяет нам впихнуть какой-нибудь эмишн, с которого на-
		чинаются другие эмишны. Например, у нас есть Observable<String>, который
		выпускает элементы, которые мы хотим напечатать в менюшке. Можно исполь-
		зовать startWith(), чтобы сначала написать заголовок менюшки.
			Observable.just("Чай", "Кофе", "Лимонад")
						.startWith("НАПИТКИ")
						.subscribe(System.out::println)
			>output: НАПИТКИ Чай Кофе Лимонад
		Если нам нужно больше, чем один элемент для старта, можно бахнуть
		- startWithArray(), тогда отработают сначала элементы массива.
		Если нужно ждать выпуск всех эмишнов другого Obsaervable, стоит 
		использовать Observable.concat() или concatWith()
		[i] - В Stayandex'е можно было бы рисовать синонимы только после того,
		как загрузился перевод.
		- defaultIfEmpty() - подставляет дефолт, если пусто. Вот это да.
		- switchIfEmpty() - переключается на другой Observable, если предыдущий
		не заэмитил ни одного элемента.
		- sorted() - если у нас есть конечный Observable<T>, который выпускает
		элементы Comparable<T>, можно юзать этот оператор, чтобы сортировать
		эмишены. Под капотом он соберёт все эмишены, а потом перевыпустит их
		в заданном порядке. Если применить к бесконечному Observable, получим 
		OutOfMemory, естесна. Можно подать Comparator в качестве аргумента.
		- delay() - собирает все элементы и выпускает затем один за одним с 
		заданным интервалом. Так как оперирует на другом шедулере, то надо это
		иметь в виду и не тупить в посках выполненной операции. Она могла не успеть
		выполниться до завершения main-потока. Для продвинутого delay() можно
		подать в него другой Observable и этот дилей отложит свои эмишены на 
		время, пока этот обзёрвабл чё-нить не выпустит. Есть также такая штука,
		как delaySubscription(), которая откладывает подписку, а не выпуск эмишнов.
		- repeat() - повторит подписку после onComplete() заданное количество раз.
		Есть ещё repeatUntil(), который принимает BooleanSupplier и продолжает
		повторения до тех пор, пока суплаер не выдаст true.
		- scan() - `rolling` аггрегатор. Аккумулирует каждый эмишн и добавляет 
		его к следующему.
			Observable.just(5, 3, 7, 10)
						.scan((accumulator, next) -> accumulator + next)
						.subscribe(System.out::println)
			>output: 5 8 15 25
		Это не обязаельно лепить для интеджеров, можно аккумулировать всё что
		угодно. Отличается от reduce() тем, что тот берёт один эмишн, когда
		отрабатывает onComplete(). Может использоваться в бесконечных обзёрваблах.
    - Reducing operators.
    Будут случаи, когда необходимо взять серии эмишенов и сконсолидировать их
    в один элемент (зачастую какой-нибудь Single). Для того есть несколько 
    операторов. Заметьте, что эти операторы работают только с конечным
    Observable, который вызывает onComplete().
        - count() - простейший оператор для объединения множества эмишенов.
        Он подсчитает количество элементов и выпустит Single, когда отработает
        onComplete(). Если нужно посчитать эмишены на бесконечном обзёрвабле,
        юзать scan().
        - reduce() - синтаксически похож на scan(), но только выдаёт последнее
        саккумулированное значение. Может выдать Single или Maybe в зависимости
        от вашей имплементации. Например, если нужон общий интеджер:
            Observable.just(5, 3, 7, 10, 2, 14)
                        .reduce((total, next) -> total + next)
                        .subscribe(System.out::println)
            >output: 41
        - all() - эта хреновена проверяет, что все элементы подпадают под
        определённый критерий и возвращает Single<Boolean>. Как только один
        из элементов не совпадает, сразу возвращает False. Не тупи и запомни:
        если вызвать all() к пустому обзёрваблу, он выдаст True.
        - any() - соответственно, если хотя бы один есть подходящий эмишн. Кстати,
        если вызвать его у пустого обзёрвабла, то он выдаст False.
        - contains() - тут всё просто: вырнёт булю, если в эмишеннах есть данный
        элемент. Работает на hashCode()/equals().
	- Collection operators.
    Аккумулируют все эмишены и собирают в одну коллекцию, типа листа или мапы.
    Затем выплёвывают эту коллекцию. Являются на самом деле ещё одной формой 
    reducing operators, но достойны отдельного параграфа. Кстати да, не стоит
    злоупотреблять этими операторами, так как это может навредить вашей реактив-
    щине: лучше обрабатывать ивенты один-за-другим, так же как они эмитяться, 
    нежели скидывать всё в кучу и потом разгребать её. Смысл эрикса тогда?
        - toList() - собирает все эмишены из Observable<T> в List<T> и выдаёт
        его в виде Single<List<T>>. После того, как Observable отстреливает
        onComplete(), лист пушится в обзёрвер. По дефолту, этот лист будет
        ArrayList'ом, можно передать capacity и задать таким образом ограниче-
        ние на количество элементов.
        - toSortedList() - собирает в сортированный лист (работает на 
        Comparator'ах). Соответственно, можно передать компаратор.
        - toMap(), toMultiMap() - для заданного Observable<T> соберёт
        в Map<K,T>, где K - ключ, полученный из лямбды Function<T,K>.
            Observable.just("Раз", "Два", "Три")
                        .toMap(s -> s.charAt(0))
                        .subscribe(System.out::println)
            >output: {Р=Раз, Д=Два, Т=Три}
        Можно и посложнее смаппить, если в лямбду передать через запятую правило
        для значения. 
            .toMap(s-> s.charAt(0), String::length)
            .subscribe(..)
            >output: {Р=3, Д=3, Т=3}
        По дефолту toMap() использует HashMap, можно запровайдить 
        ConcurrentHashMap: toMap(s-> s.charAt(0), String::length, 
                                    ConcurrentHashMap::new)
        toMultiMap() поддерживает случаи, когда хэши совпадают. Значения в таком
        случае складываются в список.
        - collect() - нужен, чтобы собрать элементы в специфическую коллекцию:
            .collect(HashSet::new, HashSet::add) соберёт в HashSet и выдаст
        Single<HashSet>. Используйте collect() вместо reduce(), когда вы собираете
        эмишены в мутабельный объект, чтобы затем получить sealed объект.
            Хороший пример с guava:
            Observable.just("Оп", "Оп", "Опана")
                        // собрали в билдер все элементы
                        .collect(ImmutableList::builder, ImmutableList::add)
                        // сбилдили неизменяемый гуавовский список
                        .map(ImmutableList.Builder::build)
                        .subscribe(..)
        В общем collect() хорош для сбора элементов в любую "нестандартную"
        для rxjava коллекцию.
	- Error recovery operators.
	Так, ну мы уже знаем про метод onError(), который пронизывает всю цепочку от
	Observable до Observer. После его срабатываения, поток завершает выполнение
	и никаких эмишенов больше не происходит. Но иногда нам надо перехватить
	ошибку до того, как она провалится до Observer'a и поток завершится с ошибкой.
		- onErrorReturn() и onErrorReturnItem() - когда нужно вернуть дефолтный
		item в случае ошибки. Принимает лямбду с Throwabl'ом. Важно, где стоит
		в цепочке. Чтобы ловить ошибку, должен стоять после обзёрвабла, который
		выдал эту ошибку (логично, потому как каждый следующий член цепочки
		является Observer'ом предыдущего члена и Observabl'ом для следущего).
		- onErrorResumeNext() - аналогичен предыдущим, только принимает ещё другой
		Observable в качестве параметра (который эмитится на случай ошибки).
		Можно по красоте бахнуть например .onErrorResumeNext(Observable.empty())
		и вызвать тем самым onComplete() в цепочке, где произошла ошибка. Искать
		только её потом устанем (прим.автора).
		- retry() - переподписывается к Observabl'у в надежде, что ошибка рассо-
		сётся сама по себе. Есть несколько перегруженных методов. Можно, например,
		задать интом количество попыток. Можно пульнуть в него Predicate<Throwable>
		или BiPredicate<Integer,Throwable>, чтобы более точно описать случай,
		когда должен отработать retry(). retryUntil() будет пересабскрайбиться
		до тех пор, пока соотв. BooleanSupplier в лямбде выдаёт false. 
		Есть также крутой retryWhen(). С его помощью можно применить композицию
		из задач для ретрая (к примеру, выставить delay для retry).

	- Action operators.
	Помогают при дебаге, улучшают понимание того, что собственно проиходит в
	чейне. Вставлять между целевым обзёрвером и его обзёрваблом (прим.автора).
		- doOnNext() - позволяет брать эмишены предыдущего Observabl'а. Что-то
		типа мини-обзёрвабла в середине цепочки. Он никак не меняет эмишены. 
		С помощью doOnNext() мы просто создаём side-effect для каждого ивента в
		цепочке. В этом примере мы просто выведем все стринги в консоль до того,
		как они упадут в оператор map():
						Observable.just("One", "Four", "Twelve")
									.doOnNext(s -> System.out::println)
									.map(String::length)
									.subscribe(System.out::println)
						>output: One 3 Four 4 Twelve 6
		Есть также doAfterNext(), который предпринимет заданное действие ПОСЛЕ
		того, как эмишн ушёл дальше по цепочке.
		- doOnComplete() - срабатывает, когда чейн вызывает свой onComplete().
		Может быть полезен в случае, когда нужно понять, какая часть цепочки
		отработала нормально и завершилась onComplete(). 
		- doOnError() - соответственно, срабатывает, когда по цепочке пробрасы-
		вается ошибка. Опять же, полезно вставлять между операторами. Тут лучше
		с примером:
			Observable.just(5, 2, 4, 0, 3, 2, 8)
						.doOnError(e -> System.out.println("Source failed")
						.map(i -> 10/i)
						.doOnError(e -> System.out.prinln("Division failed")
						.subscribe(i -> System.out::println,
									e -> System.out.println("Observer gets error");
			> output: 2 5 2 Division failed! Observer gets error
		То есть "Source failed" не отработал, так как не было выпущено никаких
		ошибок из .just(...).
		Есть также doOnEach(), где мы можем определить действие для всех трёх
		предыдущих операторов. Это типа как влепить subscribe() посередине чейна.
		-doOnSubscribe() - выпускает Consumer<Disposable> в момент, когда
		в чейне срабатывает подписка. Предоставляет доступ к Disposable на
		случай, если нам нужно вызвать dispose().
		-doOnDispose() - позволяет предпринять какую-то операцию в момент,
		когда в чейне отработал dispose(). Если нам нужно сделать что-то в любом
		случае, будь то onComplete(), onError() или dispose, нам понадобится
		doFinally(), который отрабатывает при всех трёх вариантах.
		-doOnSuccess() - как мы помним, Maybe и Single вызывают onSuccess, у них
		нет никаких onNext(). Для них есть doOnSuccess(), который работает также,
		как doOnNext(). 
	Втираем себе в виски понимание того, что action операторы
	ставятся между observer и observable и отрабатывают ДО observer'овских
	методов.

- Combining Observables.
    - Merging.
    Распространённая операция по слиянию двух и более обзёрваблов<T> в один
    Observable<T>.
        - Observable.merge() - если у нас от двух до четырёх однотипных 
        обзёрваблов, можно использовать этот оператор.
        Можно использовать source1.mergeWith(source2).subscribe(..).
        Observable.merge() и оператор mergeWith() подпишутся на все источники
        одновременно, но элементы будут эмититься в одном потоке.
        Если нам нужен поочерёдный(заданный) эмит элементов, то надо использовать 
        Observable.concat().
        Не стоит полагаться на порядок эмитов в случае с merge(), когда вам нужна
        какая-то конкретная последовательность элементов. Если такая 
        необходимость всё-таки есть, юзать concat().
        В случае, когда смёрджить надо больше четырёх обзёрваблов, использовать
        Observable.mergeArray(), который принимает varargs Observable[].
        Оказывается, можно подать также Iterable<Observable<T>> в метод merge(), и
        он нормально отработает.
        Работает с бесконечными обзёрваблами. 
        - flatMap() - вот на этом парне надо остановиться подробнее.
        Производит динамический Observable.merge(): берёт каждый эмишн и мапит
        его в Observable. Затем он мёрджит эмишены получившихся Observabl'ов в
        один поток.
        Простейшее практическое применение для flatMap() - смаппить один эмишн в
        множество эмишнов.
        К примеру, мы хотим заэмитить char из каждого String у Observable<String>.
        Для такой задачи можно использовать flatMap(), которому передадим
        Function<T, Observable<R>> в ламбду. Она смапит каждый стринг в
        Observable<String>, который будет эмитить буквы. Надо обратить внимание,
        что получившийся Observable<R> может эмитить любой элемент R только если
        он отличается от входного типа T.
            Observable<String> source Observable.just("по", "буквам");
            source.flatMap(s -> Observable.fromArray(s.split("")))
                    .subscribe(System.out::println)
            >output: п о б у к в а м
        Мы разбили каждый стринг на char, обернули это в Observable и передали
        в flatMap(), который заэмитил все char'ы в один поток.    
		 
		
		
		
	
	
